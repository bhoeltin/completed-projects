Homework 03
===========

Task 1

The program begins by deciding what the key would be based on the number of arguments. If there is zero arguments, the key will default to 13. If there is one argument, the number will be the first argument, $1. If the user enters more than 1 argument, then they get an error message and the program does not run. If the user inputs a number greater than 26, then it is replaced by 26. To create the set1 and SetA, I used an echo of lowercase a-z and uppercase a-z respectively with the cut command. The program would then only show the first MYVAR number of letters in the alphabet. The same was repeated for sets 2 and B except the range for cut started with MYVAR + 1 and went to 26 to get the second part of the CIPHER. I then created a CIPHER variable that included $SETB$SETA$SET2$SET1. This is what the tr command would use to map the normal alphabbet to.  

Task 2

To parse the arguments of the command line, I used a while loop with the shift comamnd. Since the shift command increases the number associated with each argument byy one and decreases the number of arguments by one, it could be used to create a while loop that continues until the number of arguments is below zero. If there was a -d flag, the program would reassign the delimiter to the next argument following the d. If there was a -W flag, the program would set the variable WSET to true. If WSET was true, then the program would not delete empty lines. To remove the comments, the sed command was used in its search and replace format. The command would find the delimeter line and replace it with nothing. The | had to be used to separate each of the things in the sed command in case the delimiter was a \. This command was then piped to another sed to replace spaces with nothing. In order to delete empty lines, the WSET variable had to be false. The same command for the -d delimeter without the -W was used except an extra pipe was added at the end that used the blank class to delete any blank space in the file. If no flags were placed, the program would run by deleting comments starting with # and would delete all empty lines. 

Task 3

To parse the arguments of the command line, I used a while loop	with the shift comamnd.	Since the shift	command	increases the number associated with each argument byy one and decreases the number of arguments by one, it could be used to create a while loop that continues until the number of arguments is below zero. To extract the zip codes, the grep command was used with the -E and -o flags to only display the zipcodes and not the whole line they were on. The grep command looked for a series of 5 numbers in a row. In order to filter by state, the program looked for the -s flag and took the argument after it as the name of the sate, putting it in the STATE variable. This STATE was put into the URL that the program curled as so curl -s http://www.zipcodestogo.com/{$STATE} . If only the state had been entered and not a city, I ran into a problem in that the program displayed each zip code more than once. To fix this I had to add a backslash at the end of the numbers looked for with grep. I then piped this to cut so that it only showed me the first 5 characters and left out the backslash. If no state was entered, the program would defaut to Indiana. To search for the city, the user had to put the -c flag and the program would grep the city between backslashes. If there was a space in the cities name, the program would convert that space to nothing in order to ensure that it only looked for that city and not other cities that contained that city's name (ie Orange,CA and Orange County, CA). I also used the sort and uniq commands to ensure that each zip code was only listed once and was in the proper order. If no city flag was entered, then the program would list all the zip codes in the state. To format the text as csv, the tr command was used to translate new line characters, '\n' to ','. If no format was entered it defaulted to text.

